---
title: LeetCode 2025.9.4
categories:
  - Algorithm
  - LeetCode
---

# 347 前K个高频元素

存储一个Hash表，包含每个元素的频次，维护一大小为k的小顶堆，最后输出小顶堆中的元素

python默认heapq为小顶堆

排序函数
**sorted_items = sorted(s.items(), key=lambda x: x[1], reverse=True)**

# 338 比特位计数

转换为2进制**b = bin(n)[2:]**这个得到的是字符串，减一计数

任何数与1做按位与，只会保留最低位 

DP 任何数二进制1的个数都和它整除2得到的数有关 **out[i] = out[i >> 1] + (i&1)** 和
**out[i] = out[i & (i - 1)] + 1**

# 337 打家劫舍 3 

偷了父节点就不偷左右孩子

建立一个字典储存节点值

```
    def __init__(self):
        self.tmap = {}
```

进入递归运算，偷当前节点，那么左右孩子节点就不要偷，不偷当前节点，就要偷左右孩子节点，所有在该节点偷的就是两者中大的那个

树形DP，dp[0]如果不偷当前节点可以偷到最多的，dp[1]偷当前节点，可以偷到最多的

注意，当不需要偷当前节点时，之前的节点也可以偷或者不偷，两者取大

# 121 买股票的最佳时机

找到list里的前后两个数，使他们的差最大，
直接遍历(暴力解)，
只需要一个值，因此可以使用贪心，取左侧最小值，取右侧最大值

使用DP 维护一个DP表，保存持有股票和卖出股票的金额 dp[i][0]表示买入股票的开销，dp[i][1]表示卖出股票后最多赚取的金额

# 312 戳气球

DP 更新条件：设置区间$(l,r)$一个最后被戳破的气球为k, $(l<k<r)$, 当第k个气球被戳破时，此时左右半边的两个区间$(l,k)$与$(k,r)$已经被全部访问完成了 

左右两边是独立的

因此从小窗口开始逐渐累加窗口，从初始位置开始逐个位置遍历窗口，并在窗口内逐个遍历K的位置